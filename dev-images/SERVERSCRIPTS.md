# My Application

The project is generated by [LoopBack](http://loopback.io).

file backup from local to remote server :
```bash
tar zcf - /some/directory | ssh username@server "cat > backup.tar.gz"
```
or same thing, using dump instead :
```bash
tar zcf - /some/directory | ssh username@server "dd of=filename.bz2"
```
output from local to remote server :
```bash
echo "some text" | ssh username@example.com "cat > somefile.txt"
```
or
```bash
cat ~/.ssh/id_rsa.pub | ssh username@example.com "cat >> ~/.ssh/authorized_keys"
```
backup local mysql database to remote server :
```bash
mysqldump --opt database_name | gzip -c | ssh username@example.com "cat > /remote/dir/DB_backup.gz"
```
or using tar to backup database :
```bash
mysqldump | tar cf - | gzip -c | ssh username@example.com "cat > /remote/dir/DB_backup.tar.gz"
```
execute commands on remote server :
```bash
ssh username@example.com "uname -a"
```
or execute commands on remote server but save the output to local :
```bash
ssh user@example.com "mysqldump -u DB_username -pDB_password DB_name | gzip -c" > /local/dir/DB_backup.gz
```
*** the "-p" parameter of "mysqldump" needs the value immediately after the parameter, no space.



Piping TAR datastream over SSH
Use of TAR command over SSH sessions, a good facility to transfer archives securely.

The GNU version of the tar archiving utility (and other old version of tar) can be use through network over ssh session.

1. Tarred file transfer
Scp is very inefficient when copying many small files because it sets up a separate transfer for each file. It is possible to solve this problem by creating a single archive containing all the files and piping it over SSH:
```bash
$ tar zcf - tobearchived | \
ssh user@destination_server_ip \
'tar zxf -'
```
This will put ‘tobearchived’ in the server’s home directory. It is possible to use the -C option to put the files somewhere else. (The ‘z’ tells tar to use gzip compression. To use bzip2 compressio, replace ‘z’ with ‘j’).

Copying from the server is just like the above, but in reverse:
```bash
$ ssh user@source_server_ip \
'tar zcf - tobearchived' | \
tar zxf -
```
2. Offsite backups
This is pretty much the same as above, except we want to transfer a bunch of files and leave them as a tarball on the server rather than as a bunch of files.
```bash
$ tar zcf - tobearchived | \
ssh user@destination_server_ip \
'cat - > tobearchived.tar.gz'
```

It is possible to encrypt the tarball (it GPG keyring is set up):
```bash
$ tar zcf - tobearchived | \
gpg -e | \
ssh user@destination_server_ip \
'cat - > tobearchived.tar.gz.gpg'
```

It is also possible to use a symmetric cipher:
```bash
$ tar zcf - tobearchived | \
openssl enc -rc4 | \
ssh user@destination_server_ip \
'cat - > tobearchived.tar.gz.rc4'
```
It is also possible to choose a different cipher:
```bash
$ ssh user@destination_server_ip \
'cat tobearchived.tar.gz.rc4' | \
openssl enc -rc4 -d -out tobearchived.tar.gz
```
3. Hard drive backup/mirror
This will copy the entire drive into a file on the remote machine:
```bash
$ dd if=/dev/sdX | \
ssh user@destination_server_ip \
'dd of=sdX.img'
```
To restore a local drive from the image on the server, reverse the command:
```bash
$ ssh user@source_server_ip \
'dd if=sdX.img' | \
dd of=/dev/sdX
```
Note that to read or write block devices requires you to be root. Be very careful with dd as it can be very ‘deadly’ if used carelessly.

4. Run a local script remotely
This command will run a local file script.sh on the remote server and display any output locally:
```bash
$ ssh user@destination_server_ip \
'bash -s' < script.sh
```
